from abc import ABC, abstractmethod
from inspect import Parameter
from typing import Dict, ItemsView

from lphy.core.model.Value import Value
from lphy.core.model.GraphicalModelNode import GraphicalModelNode
from lphy.core.parser.argument import ArgumentUtils


# this replaces getName()
# get generator name defined for the lphy script,
# if no attr generator_info to define the name, then use the class name
def get_generator_name(generator_class):
    if hasattr(generator_class, 'generator_info'):
        return generator_class.generator_info.get('name')
    elif isinstance(generator_class, type):
        return generator_class.__name__
    else:
        return generator_class.__class__.__name__


class Generator(GraphicalModelNode, ABC):

    # return the specification operator, for function '=' and for generative distribution '~'
    @abstractmethod
    def specification_operator(self) -> str:
        pass

    @abstractmethod
    def rev_spec_op(self) -> str:
        pass

    # return a value generated by this generator.
    @abstractmethod
    def generate(self) -> Value:
        pass

    # do not print rev var name on left side in rev script, e.g., using for loop
    def has_var_declaration_rev(self):
        return True

    def rev_code_before(self, var_name):
        """
        :return: rev code, before the code generated by :func:`lphy_to_rev`
        """
        pass

    def get_params(self) -> ItemsView:
        """
        This no longer requires to implement and fill in SortedMap<String, Value> map.
        But special case, such as MethodCall, needs to overwrite it.
        :return: pairwise items consisting of (param_name, param) extracted from __init__,
                 so require to call  .items()
        """
        constructors = ArgumentUtils.get_constructors(self.__class__)
        if len(constructors) == 1:
            # pairwise items consisting of (param_name, param)
            return ArgumentUtils.get_arguments(constructors[0])
        else:
            raise RuntimeError(f"{self.__class__.__name__} {self.get_id()} must have 1 and only 1 __init__ !")

    def get_param(self, name_) -> Value:
        """
        :param name_:  lphy arg name, also the param name in __init__
        :return:       the parameter value declared in __init__
        """
        try:
            return self.__getattribute__(name_)
        except AttributeError:
            return None

    def get_type_name(self) -> str:
        return self.__class__.__name__

    # used to make all Values know their outputs
    def set_input(self, value: Value) -> None:
        # no set_param, the params will be extracted from __init__ args
        #TODO self.set_param(param_name, value)
        value.add_output(self)

    def set_inputs(self, params: Dict[str, Value]) -> None:
        for param_name, value in params.items():
            self.set_input(value)

    def get_inputs(self):
        return list(self.get_params().values()) #TODO get_params(self) -> ItemsView

    def get_unique_id(self) -> str:
        return str(hash(self))

    def get_param_name(self, value: Value) -> str:
        for key, val in self.get_params():
            if val == value:
                return key
        return ""

    def has_random_parameters(self) -> bool:
        for value in self.get_params().values():
            if value is None:
                raise RuntimeError("Unexpected null value in generator " + get_generator_name(self))
            if value.is_random():
                return True
        return False
